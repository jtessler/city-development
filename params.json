{"name":"City Development","body":"Requirements\r\n------------\r\n* Java\r\n* Python\r\n* Subversion\r\n* [Google Closure][closure] (see below)\r\n* A WebGL-supporting platform and browser\r\n\r\nDevelopment Requirements\r\n------------------------\r\n* [Google Closure Linter](https://developers.google.com/closure/utilities/)\r\n\r\nInitial Setup\r\n-------------\r\n1. Download the [Google Closure][closure] library and compiler: `make closure`\r\n1. Compile all JavaScript files and HTML templates: `make release`\r\n1. Open `index.html` in any web browser\r\n\r\nThe Plan and Expected Results\r\n-----------------------------\r\nStudents are required to explore area calculations for various polygons\r\n(buildings), tessellation, population density, and other environmental science\r\nissues. This system provides a web-based platform for students to explore the\r\nworld they create.\r\n\r\nUsing a bird’s-eye view, students place various structures, e.g. schools,\r\nhouses, power plants, represented as polygons about a 2D grid. For each\r\nbuilding, students may specify the number of floors and, potentially, aesthetic\r\nqualities. Furthermore, initial geography and structure placements are randomly\r\ngenerated, so no two projects are alike. Every change immediately updates a\r\n3D-rendered version, where students may “fly around” and inspect the\r\nmodifications.\r\n\r\nActual Results\r\n--------------\r\n![Screenshot][screenshot]\r\n\r\nStudents can easily add, modify, and remove various building types from the\r\nscene. Each building type exposes unique modifiers to the user, e.g. the number\r\nof floors on a residential household. Camera movement is intuitive and smooth,\r\nresponding to both keyboard and mouse events. The rendered scene includes an\r\ncube-based environment map and original models that I designed and texturized in\r\nBlender. The various vertex and fragment shaders employ diffuse and specular\r\nshading to enhance the final product.\r\n\r\nI did not include the bird's-eye view, as I believe the simple UI and 3D view\r\nare sufficient. Moreover, the grid is initially blank, i.e. I did not implement\r\nthe randomization component. This better-aligns with the objectives of our final\r\ngeometry curriculum.\r\n\r\nUnexpected Results\r\n------------------\r\nAlthough the final product is not terribly advanced (given the high school\r\nstudent audience), I devoted most of my attention to the architecture,\r\nefficiency, and scalability of the underlying system. This was not my original\r\nintent, but it resulted in an immense amount of WebGL (and therefore OpenGL)\r\nresearch and exploration.\r\n\r\nI believe that I have built the foundation of a new WebGL JavaScript library\r\nthat is unique in numerous ways. After all, given the prevalence of WebGL\r\nengines available today, why did I dedicate such effort to an already saturated\r\narea?\r\n\r\nThe Library: Background and Motivation\r\n--------------------------------------\r\nFirst, unlike the majority of existing projects, I expose and embrace GLSL\r\ncoding rather than abstracting away from it. This provides much more control to\r\ncompetent graphics programmers, but eliminates most boilerplate code that\r\nlitters any raw WebGL application (without hindering any performance).\r\n\r\nSecond, no other product integrates with the [Google Closure][closure] library.\r\nNot only does this library provide developers the power of Google's framework,\r\nbut it provides a familiar environment for any current Closure project to\r\nimport. In fact, I hope to polish this project and present it to the Closure\r\nteam for possible adoption in the official library.\r\n\r\nThird, I designed both a [GLSL][glsl] and [OBJ][obj] compiler. These allow the\r\ndeveloper to design shaders and models externally, e.g. in another IDE or\r\nmodeling software like Blender. Futhermore, the compilers minimize the code and\r\nproduce JavaScript classes that are easily accessible by the rest of the WebGL\r\napplication.\r\n\r\nAs an example, compare the code two code snippets below. Each produce the same\r\ntextured cube, where the first clearly hides the redundant setup code. Notice\r\nthe `new cidev.webgl.shader.DiffuseSpecular` call, which initializes the GLSL\r\nshader that was previously compiled and automatically wrapped in a JavaScript\r\nclass.\r\n\r\n```javascript\r\nthis.context = new cidev.webgl.Context(canvas);\r\nthis.camera = new cidev.webgl.Camera(this.context);\r\nthis.modelMatrix = goog.vec.Mat4.createFloat32Identity();\r\nthis.shader = new cidev.webgl.shader.DiffuseSpecular(\r\n    this.context, this.camera, this.modelMatrix);\r\nthis.texture = new cidev.webgl.texture.Texture2D(this.context, 'texture.jpg');\r\nthis.cube = new cidev.webgl.Mesh(this.context, 'cube.obj');\r\n\r\nthis.simple.activate();\r\ngoog.vec.Mat4.makeTranslate(this.modelMatrix, x, y, z);\r\nthis.simple.render(this.cube, this.texture);\r\n```\r\n\r\nThis snippet produces the same cube with (many) raw WebGL calls.\r\n```javascript\r\nvar gl = canvas.getContext(\"experimental-webgl\");\r\nvar shaderScript = document.getElementById(\"shader-vs\");\r\n// ... omit ~50 lines compiling shaders ...\r\n\r\nvar cubeVertexPositionBuffer = gl.createBuffer();\r\ngl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);\r\nvertices = [\r\n    // Front face\r\n    -1.0, -1.0,  1.0,\r\n     1.0, -1.0,  1.0,\r\n// ... omit ~100 lines defining vertex attributes ...\r\n\r\nvar texture = gl.createTexture();\r\ngl.bindTexture(gl.TEXTURE_2D, texture);\r\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\r\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n// ... omit ~50 lines defining properties and importing textures ...\r\n\r\ngl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\r\ngl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\nmat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);\r\nmat4.identity(mvMatrix);\r\nmat4.translate(mvMatrix, [x, y, z]);\r\ngl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);\r\ngl.vertexAttribPointer(shaderProgram.vertexPositionAttribute,\r\n    cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\r\n// ... omit ~20 lines finishing shader setup and drawing ...\r\n```\r\n\r\nNavigating The Source Code\r\n--------------------------\r\n#### Root Directory Definitions ####\r\n* `artifact` Screenshots of example usage and output.\r\n* `build` The GLSL, OBJ, and index template compilers.\r\n* `cidev` The JavaScript package and WebGL library (see below).\r\n* `css` Cascading Style Sheets for the application.\r\n* `glsl` The raw GLSL vertex and fragment shaders.\r\n* `obj` The raw OBJ files.\r\n* `textures` The images used for all textures.\r\n* `tmpl` Contains the index template file.\r\n\r\n#### Javascript Package Directory Definitions ####\r\n* `base.js` The entry point.\r\n* `controller.js` The \"controller\" component of my MVC design.\r\n* `database.js` A simple in-memory database to store the models.\r\n* `scene.js` Handles all 3D rendering based on user input.\r\n* `view.js` The \"view\" component of my MVC design.\r\n* `model` The \"model\" component of my MVC design.\r\n* `testing` Test files used during development.\r\n* `webgl` The WebGL library (see below).\r\n\r\n#### WebGL Library Directory Definitions ####\r\n* `camera.js` Handles keyboard/mouse events and wraps the view matrix.\r\n* `context.js` Wraps the canvas and its corresponding WebGL context.\r\n* `mesh.js` The OBJ file wrapper.\r\n* `shader` The GLSL shader wrappers.\r\n* `texture` The WebGL texture wrappers.\r\n\r\nArtifacts\r\n---------\r\nYou may see all image artifacts [here][artifacts]. You can make your own\r\n[here][utcs]!\r\n\r\nFuture Work\r\n-----------\r\nI plan to implement more building types and improve the UI's style and\r\nfunctionality. This requires a deeper study of UV unwrapping and practice in\r\nBlender's modeling environment. However, it will make the lesson more successful\r\nwhen I implement it in the classroom next spring.\r\n\r\nI will continue the library development in hopes of presenting it to the Closure\r\nteam for official adoption. Specifically, I want to improve the compilers and\r\nexplore ways to improve the development work flow.\r\n\r\nCitations\r\n---------\r\n> Yoav I. H. Parish and Pascal Müller. 2001. Procedural modeling of cities. In\r\n> Proceedings of the 28th annual conference on Computer graphics and interactive\r\n> techniques (SIGGRAPH '01). ACM, New York, NY, USA, 301-308.\r\n> DOI=10.1145/383259.383292 http://doi.acm.org/10.1145/383259.383292\r\n\r\nI designed and texturized objects using the following sources:\r\n* [Blender](http://www.blender.org/)\r\n* [CGTexture](http://www.cgtextures.com/)\r\n\r\nI borrowed some code snippets from the following sources:\r\n* [Learning WebGL](https://github.com/gpjt/webgl-lessons)\r\n* [WebGL Earth](https://github.com/webglearth/webglearth)\r\n* [OBJ Parser](http://programminglinuxgames.blogspot.com/2010/09/parsing-wavefront-obj-file-format-using.html)\r\n\r\n[closure]: https://developers.google.com/closure/\r\n[screenshot]: https://raw.github.com/jtessler/city-development/master/artifact/screenshot01.png\r\n[glsl]: https://github.com/jtessler/city-development/blob/master/build/shaders.py\r\n[obj]: https://github.com/jtessler/city-development/blob/master/build/obj.py\r\n[artifacts]: https://github.com/jtessler/city-development/tree/master/artifact\r\n[utcs]: http://www.cs.utexas.edu/users/joseph/city-development/\r\n","google":"UA-36983820-1","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"A web-based 3D city modeling system intended for a high school geometry project."}